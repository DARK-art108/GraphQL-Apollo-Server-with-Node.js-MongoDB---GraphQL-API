"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveDependees = exports.resolveDependee = exports.isDependee = void 0;

var _objectPath = require("object-path");

var _deepEqual = _interopRequireDefault(require("deep-equal"));

var _utils = require("./utils");

var _allResolvers = require("./allResolvers");

var _pipeResolvers = require("./pipeResolvers");

var _combineResolvers = require("./combineResolvers");

var _miscResolvers = require("./miscResolvers");

/**
 * Piping resolver to save current value and reference to dependees cache.
 */
var saveDependee = (0, _combineResolvers.combineResolvers)(_miscResolvers.contextMustBeObject, function (value, args, context, info) {
  return (0, _objectPath.push)(context, '_dependees', {
    path: info.path,
    value: value
  }), value;
});
/**
 * Identify a resolver as being a dependee, so other sibling
 * field resolvers might depend on the value resolved by this one.
 *
 * Basically, it will polute "info" during resolving
 * to insert the resolved value and path to this resolver.
 *
 * @param {Function} resolver Resolver implementation.
 * @return {Promise}.
 */

var isDependee = function isDependee(resolver) {
  return function (root) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return saveDependee.apply(void 0, [resolver.apply(void 0, [root].concat(args))].concat(args));
  };
};
/**
 * Make sure the field name exists on the parent type.
 *
 * @param {String} dependeeName The name of the dependee to check the parent against
 * @return {Function} Resolver to error when no dependee is found.
 */


exports.isDependee = isDependee;

var dependeeExists = function dependeeExists(dependeeName) {
  return function (root, args, context, _ref) {
    var fieldName = _ref.fieldName,
        _ref$parentType = _ref.parentType,
        _fields = _ref$parentType._fields,
        parent = _ref$parentType.name;
    return !_fields[dependeeName] ? new Error("Cannot get dependee \"".concat(dependeeName, "\" from field \"").concat(fieldName, "\" on type \"").concat(parent, "\"")) : _utils.skip;
  };
};
/**
 * Resolver implementation to retrieve the resolved value of a dependee sibling field.
 *
 * @param {String} dependeeName The name of the dependee this resolver depends on.
 * @param {Function} resolver Resolver implemenatation.
 * @return {Function} dependee resolver.
 */


var resolveDependee = function resolveDependee(dependeeName) {
  return (0, _combineResolvers.combineResolvers)(_miscResolvers.contextMustBeObject, dependeeExists(dependeeName), (0, _pipeResolvers.pipeResolvers)( // Make sure dependent resolvers occur after
  // dependees have been initialized.
  _utils.nextTick, function (root, args, context, info) {
    var _context$_dependees = context._dependees,
        _dependees = _context$_dependees === void 0 ? [] : _context$_dependees; // Find any currently resolved dependee.


    var resolved = _dependees.filter(function (_ref2) {
      var prev = _ref2.path.prev;
      return (0, _deepEqual["default"])(prev, info.path.prev);
    }).find(function (_ref3) {
      var key = _ref3.path.key;
      return key === dependeeName;
    }); // Run field resolution, if resolved value was not found.


    return resolved === _utils.skip ? info.parentType._fields[dependeeName].resolve(root, args, context, info) : resolved.value;
  }));
};
/**
 * Resolver implementation to retrieve the resolved value of multiple dependee sibling fields.
 *
 * @param {[String]} dependeeNames Array of names of the dependees this resolver depends on.
 * @param {Function} resolver Resolver implemenatation.
 * @return {Function} dependee resolver.
 */


exports.resolveDependee = resolveDependee;

var resolveDependees = function resolveDependees(dependeeNames) {
  return (0, _combineResolvers.combineResolvers)(_miscResolvers.contextMustBeObject, (0, _allResolvers.allResolvers)(dependeeNames.map(resolveDependee)));
};

exports.resolveDependees = resolveDependees;